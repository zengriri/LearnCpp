简述：
    数据类型其实本质上就是告诉CPU在内存中占用字节的大小。，可以保存的数值为:2^n(单位:bit) 
    1bite = 8bit


The sizeof operator
        不同的机器可能会导致相同类型所占用的字节大小不一样。

        可使用 sizeof 来检查
            eg:
                 sizeof(bool)



Fixed-width integers:
    C99 定义了一组固定宽度的整数（在 stdint.h 头文件中），这些整数保证在任何架构上都具有相同的大小
    eg:std::int8_t,std::uint8_t等

    C++ 正式采用这些固定宽度整数作为 C++11 的一部分。可以通过包含 <cstdint> 标头来访问它们，它们在 std 命名空间中定义

    缺点：
        1:不能保证在所有架构上都定义了固定宽度整数
            它们仅存在于存在与其宽度匹配并遵循某种二进制表示的基本类型的系统上。您的程序将无法在任何不支持您的程序正在使用的固定宽度整数的架构上编译。
            然而，鉴于大多数现代架构都围绕 8/16/32/64 位变量进行了标准化，除非您的程序需要移植到某些特殊的大型机或嵌入式架构，否则这不太可能成为问题。

        2:如果您使用固定宽度的整数，在某些架构上它可能会比更宽的类型慢。
            eg:
                如果您需要一个保证为 32 位的整数，您可能会决定使用 std::int32_t，但您的 CPU 实际上在处理 64 位整数时可能更快。
                但是，仅仅因为您的 CPU 可以更快地处理给定类型并不意味着您的程序总体上会更快--现代程序通常受内存使用而不是 CPU 的限制，并且较大的内存占用可能会使您的程序变慢，而不是更快的 CPU 处理加速它。不实际测量很难知道。


Fast and least integers:
    为了帮助解决上述缺点，C++ 还定义了保证定义的两组替代整数。
    
    快速类型（std::int_fast#_t 和 std::uint_fast#_t）提供最快的有符号/无符号整数类型，宽度至少为 # 位（其中 # = 8、16、32 或 64）。
        eg：
            std::int_fast32_t 将为您提供最快的有符号整数类型，至少为 32 位。

    最小类型（std::int_least#_t 和 std::uint_least#_t）提供宽度至少为 # 位（其中 # = 8、16、32 或 64）的最小有符号/无符号整数类型。
        eg:
            std::uint_least32_t 将为您提供至少 32 位的最小无符号整数类型。

    缺点:
        1:使用它们的程序员并不多，缺乏熟悉可能会导致错误
        2:快速类型会导致相同类型的内存浪费。最严重的是，由于快速/最小整数的大小可能会有所不同，因此您的程序可能会在解析为不同大小的架构上表现出不同的行为


std::size_t：
     *std::size_t 定义为无符号整数类型，通常用于表示对象的大小或长度。

     *就像整数的大小可能因系统而异一样，std::size_t 的大小也会有所不同。 std::size_t 保证为无符号且至少为 16 位，但在大多数系统上将等同于应用程序的地址宽度。
