*概述：
    程序使用的内存通常分为几个不同的区域，称为段：
        *代码段（也称为文本段），编译后的程序位于内存中。代码段通常是只读的
        *bss 段（也称为未初始化数据段），存储零初始化的全局变量和静态变量。
        *数据段（也称为初始化数据段），存储初始化的全局变量和静态变量。
        *堆，动态分配的变量从其中分配。
        *调用堆栈，存储函数参数、局部变量和其他与函数相关的信息。


*堆段：
    堆段（也称为“自由存储”）跟踪用于动态内存分配的内存，使用 new 和 delete 进行动态内存分配
        当删除动态分配的变量时，内存将“返回”到堆，然后可以在收到未来分配请求时重新分配。
        请记住，删除指针并不会删除变量，它只是将关联地址处的内存返回给操作系统。

    堆有优点也有缺点：
        *在堆上分配内存相对较慢。
        *分配的内存将保持分配状态，直到它被专门释放（注意内存泄漏）或应用程序结束（此时操作系统应该清理它）
        *动态分配的内存必须通过指针来访问。解引用指针比直接访问变量慢。
        *因为堆是一个很大的内存池，所以可以在这里分配大型数组、结构或类。


*调用堆栈：
    *调用堆栈段保存用于调用堆栈的内存。当应用程序启动时，操作系统将 main() 函数推送到调用堆栈上。然后程序开始执行。
        当遇到函数调用时，函数被压入调用堆栈。当当前函数结束时，该函数将从调用堆栈中弹出（此过程有时称为展开堆栈）。
        因此，通过查看当前调用堆栈上的函数，我们可以看到为到达当前执行点而调用的所有函数

    *Stack overflow：
        堆栈的大小有限，因此只能保存有限数量的信息。在 Visual Studio for Windows 上，默认堆栈大小为 1MB。对于 Unix 变体的 g++/Clang，它可以大到 8MB。
            如果程序试图在堆栈上放入太多信息，就会导致堆栈溢出。当堆栈中的所有内存都已分配时，就会发生堆栈溢出-- 在这种情况下，进一步的分配开始溢出到内存的其他部分。