*随着程序变得越来越大（并使用更多文件），必须转发声明您想要使用的在不同文件中定义的每个函数变得越来越乏味。而头文件的目的就在于此，头文件的主要用途是将声明传播到代码 (.cpp) 文件。
    头文件允许我们将声明放在一个位置，然后在需要的地方导入它们。这可以节省多文件程序中的大量输入。

头文件仅由两部分组成：
    *1：头文件保护
    *2：头文件的实际内容，应该是我们希望其他文件能够看到的所有标识符的前向声明


Key insight：当您 #include 文件时，所包含文件的内容将插入到包含点。这提供了一种从另一个文件中提取声明的有用方法。
            考虑一下如果 iostream 标头不存在会发生什么。无论您在何处使用 std::cout，都必须手动键入或复制与 std::cout 相关的所有声明到使用 std::cout 的每个文件的顶部。
            这需要大量有关如何声明 std::cout 的知识，并且需要大量工作，更糟糕的是，如果添加或更改了函数原型，我们就必须手动更新所有前向声明。
            
            而有了头文件，只需 #include <iostream> 就容易多了！


尖括号(<>)与双引号(""):
        *具有相同文件名的头文件可能存在于多个目录中。我们使用尖括号与双引号有助于为预处理器提供应在何处查找头文件的线索
            *当我们使用尖括号时:
                我们告诉预处理器这是一个不是我们自己编写的头文件。预处理器将仅在包含目录指定的目录中搜索标头.
                包含目录被配置为项目/IDE 设置/编译器设置的一部分，通常默认为包含编译器和/或操作系统附带的头文件的目录.
                预处理器不会在项目的源代码目录中搜索头文件

            *当我们使用双引号时:
                我们告诉预处理器这是我们编写的头文件。预处理器首先会在当前目录中查找头文件。如果在那里找不到匹配的标头，它将搜索包含目录

    rule:使用双引号包含您已编写的头文件或预计在当前目录中找到的头文件.使用尖括号包含编译器、操作系统或在系统其他位置安装的第三方库附带的标头.


为什么iostream没有.h扩展名:答案是iostream.h是与iostream不同的头文件！要进行解释，需要简短的历史课。
    *当 C++ 最初创建时，标准库中的所有文件都以 .h 后缀结尾。生活是一致的，而且很好。 cout 和 cin 的原始版本在 iostream.h 中声明.
    当 ANSI 委员会对该语言进行标准化时，他们决定将标准库中使用的所有名称移至 std 命名空间中，以帮助避免与用户声明的标识符发生命名冲突.
    然而，这提出了一个问题：如果他们将所有名称移到 std 命名空间中，则所有旧程序（包括 iostream.h）都将不再工作！
    为了解决此问题，引入了一组缺少 .h 扩展名的新头文件.
    这些新的头文件声明了 std 命名空间内的所有名称。这样，包含#include <iostream.h>的旧程序不需要重写，而较新的程序可以#include <iostream>。
    此外，许多从 C 继承但在 C++ 中仍然有用的库都被赋予了 c 前缀（例如 stdlib.h 变成了 cstdlib）。

Best practice:
    为了最大限度地提高编译器标记缺失包含的机会，请按如下顺序添加 #include
        *1：配对的头文件
        *2：您项目中的其他标头
        *3：3rd 方库头
        *4:标准库头文件

    这样，如果您的用户定义标头之一缺少第三方库或标准库标头的#include，则更有可能导致编译错误，因此您可以修复它

note:
    *1:您应该避免将函数或变量定义放在头文件中。如果头文件包含在多个源文件中，这样做通常会导致违反单一定义规则 (ODR)

    *2:避免 #include .cpp 文件 
        *这样做可能会导致源文件之间的命名冲突
        *在大型项目中，很难避免单一定义规则 (ODR) 问题
        *对此类 .cpp 文件的任何更改都将导致该 .cpp 文件和包含该文件的任何其他 .cpp 文件重新编译，这可能需要很长时间。标头的更改频率往往低于源文件
        *这样做是非常规的。

    *3:当包含标准库中的头文件时，请使用不带 .h 扩展名的版本（如果存在）。用户定义的标头仍应使用 .h 扩展名。
    
    *4包含其他目录中的头文件
        *一种（不好的）方法是在 #include 行中包含要包含的头文件的相对路径,虽然这可以编译（假设文件存在于这些相对目录中），但这种方法的缺点是它要求您在代码中反映目录结构
        如果您更新了目录结构，您的代码将不再有效。
            eg: #include "headers/myHeader.h"
                #include "../moreHeaders/myOtherHeader.h"

        *更好的方法是告诉你的编译器或 IDE 你在其他位置有一堆头文件，这样当它在当前目录中找不到它们时就会去那里查找.这通常可以通过在 IDE 项目设置中设置包含路径或搜索目录来完成

#pragma once:现代编译器使用 #pragma 预处理器指令支持更简单的替代形式的标头保护.
        #pragma Once 与标头保护具有相同的目的：避免标头文件被多次包含
        对于传统的标头保护，开发人员负责保护标头（通过使用预处理器指令#ifndef、#define 和#endif）。

        note:由于 #pragma Once 不是由 C++ 标准定义的，因此某些编译器可能不会实现它。因此，一些开发公司（例如 Google）建议使用传统的标头防护

头文件最佳实践:
    *始终包含头文件保护:标头保护的目标是防止代码文件接收受保护标头的多个副本.
        eg:
            #ifndef SQUARE_H
            #define SQUARE_H
            //content
            #endif
    *不要在头文件中定义变量和函数（暂时）
    *为头文件指定与其关联的源文件相同的名称（例如，grades.h 与grades.cpp 配对）
    *每个头文件应该有特定的工作，并且尽可能独立。
    *请注意您需要为代码文件中使用的功能显式包含哪些标头，以避免无意的传递包含
    *仅 #include 您需要的内容（不要仅仅因为可以就包含所有内容）
    *不要#include .cpp 文件
    *最好在头文件中放置有关某项功能或如何使用它的文档。在那里更容易看到它。描述某些内容如何工作的文档应保留在源文件中


        



    