short int:16bit, int,:16bit long int:32bit,long long int:64bit
     C++ 仅保证整数具有特定的最小大小，而不保证它们具有特定的大小

     *固定宽度整数
        为了解决上述问题，C99 定义了一组固定宽度整数（在 stdint.h 标头中），保证在任何体系结构上具有相同的大小.
        C++ 正式采用这些固定宽度整数作为 C++11 的一部分。可以通过包含 <cstdint> 标头来访问它们，它们在 std 命名空间内定义
            eg: std::int8_t, std::uint8_t, std::int16_t, std::uint16_t, std::int32_t, std::uint32_t, std::int64_t, std::uint64_t
        
        固定宽度整数有两个通常会出现的缺点
            1:首先，不保证在所有体系结构上都定义固定宽度整数。
            2:其次，如果您使用固定宽度的整数，在某些体系结构上它可能会比更宽的类型慢
                eg:如果您需要一个保证为32位的整数，您可能决定使用std::int32_t，但是您的CPU实际上可能在处理64位整数时更快。

    *快速和最小整数
        为了帮助解决上述缺点，C++ 还定义了两个保证定义的替代整数集。
            快速类型（std::int_fast#_t 和 std::uint_fast#_t）提供最快的有符号/无符号整数类型，宽度至少为 # 位（其中 # = 8、16、32 或 64）。
                eg:std::int_fast32_t 将为您提供最快的有符号整数类型，至少为 32 位。所谓最快，是指 CPU 处理速度最快的整型。

            最小类型（std::int_least#_t 和 std::uint_least#_t）提供宽度至少为 # 位的最小有符号/无符号整数类型（其中 # = 8、16、32 或 64）
                eg:std::uint_least32_t 将为您提供至少 32 位的最小无符号整数类型。

        然而,这些快速和最小整数有其自身的缺点:
            1:真正使用它们的程序员并不多，不熟悉可能会导致错误
            2:快速类型可能会导致内存浪费，因为它们的实际大小可能大于其名称所示的大小
            3:更严重的是，由于快速/最小整数的大小可能会有所不同，因此您的程序可能会在解析为不同大小的体系结构上表现出不同的行为

    *std::size_t :被定义为实现定义的无符号整数类型。
        std::size_t 通常用于表示对象的大小或长度，特别是在标准库中。

        最佳实践:
            1:如果您在代码中显式使用 std::size_t，请 #include 定义 std::size_t 的标头之一（我们建议 <cstddef>）。
            2:使用 sizeof 不需要标头（即使它返回类型为 std::size_t 的值）

            就像整数的大小可以根据系统的不同而变化一样，std::size_t 的大小也可以变化。 std::size_t 保证是无符号的且至少为 16 位，但在大多数系统上将等于应用程序的地址宽度.
            也就是说，对于 32 位应用程序，std::size_t 通常是 32 位无符号整数，而对于 64 位应用程序，std::size_t 通常是 64 位无符号整数。


    *整数类型的最佳实践
        1:当整数的大小无关紧要（例如，该数字始终适合 2 字节有符号整数的范围）并且变量是短暂的（例如，在函数结束时被销毁）时，首选 int
        2:当存储需要保证范围的数量时，首选 std::int#_t
        3:在进行位操作或需要明确定义的环绕行为时，首选 std::uint#_t

        尽可能避免以下情况：
            1:shor和long int——使用固定宽度类型。
            2:持有数量的无符号类型
            3:8 位固定宽度整数类型。
            4:快速和最小固定宽度类型。
            5:任何特定于编译器的固定宽度整数
                eg:Visual Studio 定义 __int8、__int16 等......

float:4bytes,double:bytes,long double:bytes:
    与整数一样，C++ 没有定义这些类型的实际大小（但它保证最小大小）

    使用浮点文字时，始终至少包含一位小数（即使小数为 0）。这有助于编译器理解该数字是浮点数而不是整数
        eg double y{5.0}

    最佳实践:除非空间非常宝贵，否则优先选择双倍浮动，因为浮动缺乏精度通常会导致不准确。

    结论:
        1:浮点数对于存储非常大或非常小的数字非常有用，包括那些带有小数部分的数字
        2:浮点数通常具有较小的舍入误差，即使该数字的有效位数少于精度.很多时候，这些数据会被忽视，因为它们太小，而且数字在输出时被截断。     
            然而，浮点数的比较可能不会给出预期的结果。对这些值执行数学运算将导致舍入误差变大。   

char:
    char 数据类型被设计为保存单个字符。字符可以是单个字母、数字、符号或空格
    char 数据类型是整型，这意味着基础值存储为整数
    ASCII 代表美国信息交换标准代码，它定义了一种将英文字符（加上一些其他符号）表示为 0 到 127 之间的数字（称为 ASCII 代码或代码点）的特定方式。
        例如，ASCII 代码 97 被解释为字符“a”。

    *C++11 中添加了 char16_t 和 char32_t，以提供对 16 位和 32 位 Unicode 字符的显式支持。
    *C++20 中添加了 char8_t 以提供对 8 位 Unicode (UTF-8) 的支持。它是一种独特的类型，使用与 unsigned char 相同的表示形式

    警告:请注意不要将字符数与整数混淆。
        eg:
            char ch{5}; // initialize with integer 5 (stored as integer 5)
            char ch{'5'}; // initialize with code point for '5' (stored as integer 53)


bool,char:
    从技术上讲，bool 和 char 类型被认为是整型（因为这些类型将它们的值存储为整数值）

void类型： 表示没有类型
    void是不完整类型，不完整类型是已声明但尚未定义的类型。
    编译器知道此类类型的存在，但没有足够的信息来确定为该类型的对象分配多少内存。
    void 是故意不完整的，因为它表示缺少类型，因此无法定义

    Void 通常用于多种不同的上下文中：
        *1：指示函数不返回值
        *2：不带参数的函数（已弃用）
            eg:  int getValue(void) {}

        *3:void指针
            也称为通用指针，是一种特殊类型的指针，可以指向任何数据类型的对象！ void 指针的声明方式与普通指针类似，使用 void 关键字作为指针的类型
        

               
