short int:16bit, int,:16bit long int:32bit,long long int:64bit
     C++ 仅保证整数具有特定的最小大小，而不保证它们具有特定的大小

     *固定宽度整数
        为了解决上述问题，C99 定义了一组固定宽度整数（在 stdint.h 标头中），保证在任何体系结构上具有相同的大小.
        C++ 正式采用这些固定宽度整数作为 C++11 的一部分。可以通过包含 <cstdint> 标头来访问它们，它们在 std 命名空间内定义
            eg: std::int8_t, std::uint8_t, std::int16_t, std::uint16_t, std::int32_t, std::uint32_t, std::int64_t, std::uint64_t
        
        固定宽度整数有两个通常会出现的缺点
            1:首先，不保证在所有体系结构上都定义固定宽度整数。
            2:其次，如果您使用固定宽度的整数，在某些体系结构上它可能会比更宽的类型慢
                eg:如果您需要一个保证为32位的整数，您可能决定使用std::int32_t，但是您的CPU实际上可能在处理64位整数时更快。

    *快速和最小整数
        为了帮助解决上述缺点，C++ 还定义了两个保证定义的替代整数集。
            快速类型（std::int_fast#_t 和 std::uint_fast#_t）提供最快的有符号/无符号整数类型，宽度至少为 # 位（其中 # = 8、16、32 或 64）。
                eg:std::int_fast32_t 将为您提供最快的有符号整数类型，至少为 32 位。所谓最快，是指 CPU 处理速度最快的整型。

            最小类型（std::int_least#_t 和 std::uint_least#_t）提供宽度至少为 # 位的最小有符号/无符号整数类型（其中 # = 8、16、32 或 64）
                eg:std::uint_least32_t 将为您提供至少 32 位的最小无符号整数类型。

        然而,这些快速和最小整数有其自身的缺点:
            1:真正使用它们的程序员并不多，不熟悉可能会导致错误
            2:快速类型可能会导致内存浪费，因为它们的实际大小可能大于其名称所示的大小
            3:更严重的是，由于快速/最小整数的大小可能会有所不同，因此您的程序可能会在解析为不同大小的体系结构上表现出不同的行为

    *std::size_t :被定义为实现定义的无符号整数类型。
        std::size_t 通常用于表示对象的大小或长度，特别是在标准库中。

        最佳实践:
            1:如果您在代码中显式使用 std::size_t，请 #include 定义 std::size_t 的标头之一（我们建议 <cstddef>）。
            2:使用 sizeof 不需要标头（即使它返回类型为 std::size_t 的值）

            就像整数的大小可以根据系统的不同而变化一样，std::size_t 的大小也可以变化。 std::size_t 保证是无符号的且至少为 16 位，但在大多数系统上将等于应用程序的地址宽度.
            也就是说，对于 32 位应用程序，std::size_t 通常是 32 位无符号整数，而对于 64 位应用程序，std::size_t 通常是 64 位无符号整数。

    *默认情况下，C++ 以十进制输出值。但是，您可以通过使用 std::dec、std::oct 和 std::hex I/O 操纵器来更改输出格式：

    *整数类型的最佳实践
        1:当整数的大小无关紧要（例如，该数字始终适合 2 字节有符号整数的范围）并且变量是短暂的（例如，在函数结束时被销毁）时，首选 int
        2:当存储需要保证范围的数量时，首选 std::int#_t
        3:在进行位操作或需要明确定义的环绕行为时，首选 std::uint#_t

        尽可能避免以下情况：
            1:shor和long int——使用固定宽度类型。
            2:持有数量的无符号类型
            3:8 位固定宽度整数类型。
            4:快速和最小固定宽度类型。
            5:任何特定于编译器的固定宽度整数
                eg:Visual Studio 定义 __int8、__int16 等......

float:4bytes,double:bytes,long double:bytes:
    与整数一样，C++ 没有定义这些类型的实际大小（但它保证最小大小）

    使用浮点文字时，始终至少包含一位小数（即使小数为 0）。这有助于编译器理解该数字是浮点数而不是整数
        eg double y{5.0}

    最佳实践:除非空间非常宝贵，否则优先选择双倍浮动，因为浮动缺乏精度通常会导致不准确。

    结论:
        1:浮点数对于存储非常大或非常小的数字非常有用，包括那些带有小数部分的数字
        2:浮点数通常具有较小的舍入误差，即使该数字的有效位数少于精度.很多时候，这些数据会被忽视，因为它们太小，而且数字在输出时被截断。     
            然而，浮点数的比较可能不会给出预期的结果。对这些值执行数学运算将导致舍入误差变大。   

char:
    char 数据类型被设计为保存单个字符。字符可以是单个字母、数字、符号或空格
    char 数据类型是整型，这意味着基础值存储为整数
    ASCII 代表美国信息交换标准代码，它定义了一种将英文字符（加上一些其他符号）表示为 0 到 127 之间的数字（称为 ASCII 代码或代码点）的特定方式。
        例如，ASCII 代码 97 被解释为字符“a”。

    *C++11 中添加了 char16_t 和 char32_t，以提供对 16 位和 32 位 Unicode 字符的显式支持。
    *C++20 中添加了 char8_t 以提供对 8 位 Unicode (UTF-8) 的支持。它是一种独特的类型，使用与 unsigned char 相同的表示形式
    *除非您计划使程序兼容 Unicode，否则不需要使用 char8_t、char16_t 或 char32_t
    *同时，在处理字符（和字符串）时应该只使用 ASCII 字符。使用其他字符集中的字符可能会导致您的字符显示不正确。

    警告:
        请注意不要将字符数与整数混淆。
            eg:
                char ch{5}; // initialize with integer 5 (stored as integer 5)
                char ch{'5'}; // initialize with code point for '5' (stored as integer 53)

        std::int8_t 和 std::uint8_t 的行为可能类似于字符而不是整数
            大多数编译器将 std::int8_t 和 std::uint8_t （以及相应的快速和最小固定宽度类型）分别定义和处理为有符号 char 和无符号 char 类型.
            相反，其他固定宽度类型将始终作为整数值进行打印和输入。


bool,char:
    从技术上讲，bool 和 char 类型被认为是整型（因为这些类型将它们的值存储为整数值）

void类型： 表示没有类型
    void是不完整类型，不完整类型是已声明但尚未定义的类型。
    编译器知道此类类型的存在，但没有足够的信息来确定为该类型的对象分配多少内存。
    void 是故意不完整的，因为它表示缺少类型，因此无法定义

    Void 通常用于多种不同的上下文中：
        *1：指示函数不返回值
        *2：不带参数的函数（已弃用）
            eg:  int getValue(void) {}

        *3:void指针
            也称为通用指针，是一种特殊类型的指针，可以指向任何数据类型的对象！ void 指针的声明方式与普通指针类似，使用 void 关键字作为指针的类型



章节回顾:
    *内存的最小单位是二进制数字，也称为位。可直接寻址（访问）的最小内存单位是字节。现代标准是一个字节等于 8 位。

    *数据类型告诉编译器如何以某种有意义的方式解释内存的内容。
        C++ 支持许多基本数据类型，包括浮点数、整数、布尔值、字符、空指针和 void

    *不同的类型占用不同的内存量，并且使用的内存量可能因机器而异
    *sizeof 运算符可用于返回类型的大小（以字节为单位）。
    *Signed integers用于保存正整数和负整数，包括 0。特定数据类型可以保存的值的集合称为其范围。使用整数时，请注意溢出和整数除法问题
    *Unsigned integers仅包含正数（和 0），通常应避免使用，除非您正在进行位级操作
    *Fixed-width integers固定宽度整数是具有保证大小的整数，但它们可能并不存在于所有体系结构上
        快速整数和最小整数是至少有一定大小的最快且最小的整数。通常应避免使用 std::int8_t 和 std::uint8_t，因为它们的行为往往类似于字符而不是整数。
    size_t 是一个无符号整数类型，用于表示对象的大小或长度。

    *科学记数法是一种书写冗长数字的速记方式。 C++ 支持科学记数法与浮点数的结合。尾数中的数字（e之前的部分）称为有效数字
    *浮点是一组旨在保存实数（包括带有小数部分的实数）的类型。数字的精度定义了它在不丢失信息的情况下可以表示多少个有效数字
        数字的精度定义了它能表示多少位有效数字而不丢失信息。当浮点数中存储了太多有效数字而不能保持那么高的精度时，可能会发生舍入错误。
        舍入错误一直都在发生，即使是像0.1这样的简单数字。因此，不应该直接比较浮点数。

    *Char 用于存储解释为 ASCII 字符的值。使用字符时，请注意不要混淆 ASCII 代码值和数字。将 char 打印为整数值需要使用 static_cast


        

               
