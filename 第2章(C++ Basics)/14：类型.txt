short int:16bit, int,:16bit long int:32bit,long long int:64bit
     C++ 仅保证整数具有特定的最小大小，而不保证它们具有特定的大小

     *固定宽度整数
        为了解决上述问题，C99 定义了一组固定宽度整数（在 stdint.h 标头中），保证在任何体系结构上具有相同的大小.
        C++ 正式采用这些固定宽度整数作为 C++11 的一部分。可以通过包含 <cstdint> 标头来访问它们，它们在 std 命名空间内定义
            eg: std::int8_t, std::uint8_t, std::int16_t, std::uint16_t, std::int32_t, std::uint32_t, std::int64_t, std::uint64_t
        
        固定宽度整数有两个通常会出现的缺点
            1:首先，不保证在所有体系结构上都定义固定宽度整数。
            2:其次，如果您使用固定宽度的整数，在某些体系结构上它可能会比更宽的类型慢
                eg:如果您需要一个保证为32位的整数，您可能决定使用std::int32_t，但是您的CPU实际上可能在处理64位整数时更快。

    *快速和最小整数
        为了帮助解决上述缺点，C++ 还定义了两个保证定义的替代整数集。
            快速类型（std::int_fast#_t 和 std::uint_fast#_t）提供最快的有符号/无符号整数类型，宽度至少为 # 位（其中 # = 8、16、32 或 64）。
                eg:std::int_fast32_t 将为您提供最快的有符号整数类型，至少为 32 位。所谓最快，是指 CPU 处理速度最快的整型。

            最小类型（std::int_least#_t 和 std::uint_least#_t）提供宽度至少为 # 位的最小有符号/无符号整数类型（其中 # = 8、16、32 或 64）
                eg:std::uint_least32_t 将为您提供至少 32 位的最小无符号整数类型。

        然而,这些快速和最小整数有其自身的缺点:
            1:真正使用它们的程序员并不多，不熟悉可能会导致错误
            2:快速类型可能会导致内存浪费，因为它们的实际大小可能大于其名称所示的大小
            3:更严重的是，由于快速/最小整数的大小可能会有所不同，因此您的程序可能会在解析为不同大小的体系结构上表现出不同的行为

    *std::size_t :被定义为实现定义的无符号整数类型。
        std::size_t 通常用于表示对象的大小或长度，特别是在标准库中。

        最佳实践:
            1:如果您在代码中显式使用 std::size_t，请 #include 定义 std::size_t 的标头之一（我们建议 <cstddef>）。
            2:使用 sizeof 不需要标头（即使它返回类型为 std::size_t 的值）

            就像整数的大小可以根据系统的不同而变化一样，std::size_t 的大小也可以变化。 std::size_t 保证是无符号的且至少为 16 位，但在大多数系统上将等于应用程序的地址宽度.
            也就是说，对于 32 位应用程序，std::size_t 通常是 32 位无符号整数，而对于 64 位应用程序，std::size_t 通常是 64 位无符号整数。


    *整数类型的最佳实践
        1:当整数的大小无关紧要（例如，该数字始终适合 2 字节有符号整数的范围）并且变量是短暂的（例如，在函数结束时被销毁）时，首选 int
        2:当存储需要保证范围的数量时，首选 std::int#_t
        3:在进行位操作或需要明确定义的环绕行为时，首选 std::uint#_t

        尽可能避免以下情况：
            1:shor和long int——使用固定宽度类型。
            2:持有数量的无符号类型
            3:8 位固定宽度整数类型。
            4:快速和最小固定宽度类型。
            5:任何特定于编译器的固定宽度整数
                eg:Visual Studio 定义 __int8、__int16 等......


bool,char:
    从技术上讲，bool 和 char 类型被认为是整型（因为这些类型将它们的值存储为整数值）

void类型： 表示没有类型
    void是不完整类型，不完整类型是已声明但尚未定义的类型。
    编译器知道此类类型的存在，但没有足够的信息来确定为该类型的对象分配多少内存。
    void 是故意不完整的，因为它表示缺少类型，因此无法定义

    Void 通常用于多种不同的上下文中：
        *1：指示函数不返回值
        *2：不带参数的函数（已弃用）
            eg:  int getValue(void) {}

        *3:void指针
            也称为通用指针，是一种特殊类型的指针，可以指向任何数据类型的对象！ void 指针的声明方式与普通指针类似，使用 void 关键字作为指针的类型
        

               
