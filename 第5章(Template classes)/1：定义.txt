模板类拆分:
    模板不是类或函数——它是用于创建类或函数的模板

    对于非模板类，常见的过程是将类定义放在头文件中，将成员函数定义放在类似名称的代码文件中
        但是，对于模板，这不起作用。考虑以下    
            eg:1-1
                error:
                    unresolved external symbol "public: int __thiscall Array<int>::getLength(void)" (?GetLength@?$Array@H@@QAEHXZ)


        *为了让编译器使用模板，它必须同时看到模板定义（不仅仅是声明）和用于实例化模板的模板类型。
        *还要记住 C++ 单独编译文件。
            当 Array.h 标头在 main 中#included 时，模板类定义被复制到 main.cpp。
                当编译器发现我们需要两个模板实例 Array<int> 和 Array<double> 时，它将实例化它们，并将它们编译为 main.cpp 的一部分。

            然而，当它开始单独编译 Array.cpp 时，它会忘记我们需要一个 Array<int> 和 Array<double>，因此模板函数永远不会被实例化.
                因此，我们得到一个链接器错误，因为编译器找不到 Array<int>::getLength() 或 Array<double>::getLength() 的定义。


        有很多方法可以解决这个问题:
            *1：最简单的方法是简单地将所有模板类代码放在头文件中（在这种情况下，将 Array.cpp 的内容放入 Array.h 中，在类下面）。
                这样，当您#include 标头时，所有模板代码都将在一个位置。这个解决方案的好处是它很简单
                这样做的缺点是，如果模板类在很多地方被使用，您将得到很多模板类的本地副本，这将增加您的编译和链接时间(您的链接器应该删除重复的定义，所以它不应该使您的可执行文件膨胀)。
                这是我们首选的解决方案，除非编译或链接时间开始成为问题。

            *2：另一种方法是将 Array.cpp 的内容移动到一个名为 Array.inl 的新文件（.inl 代表内联），然后在 Array.h 标头的底部（在标头保护内）包含 Array.inl。
                这与将所有代码放在标题中产生相同的结果，但有助于使内容更有条理。

                从构建中排除 .inl 通常可以通过在项目视图中右键单击 .inl 文件，然后选择属性来完成
                    .该设置将在那里的某个地方。
                        eg：
                             In Visual Studio, set “Exclude From Build” to “Yes”. In Code::Blocks, uncheck “Compile file” and “Link file”.

                提示:
                    如果您使用 .inl 方法，然后收到有关重复定义的编译器错误，则您的编译器很可能将 .inl 文件编译为项目的一部分，就好像它是一个代码文件一样。
                    这将导致.inl的内容被编译两次:一次是当编译器编译.inl时，一次是当包含.inl的.cpp文件被编译时，而我们会违反一个定义规则。如果发生这种情况，您将需要排除.inl文件作为构建的一部分进行编译。

            *3：另一种选择是使用第三方文件方法
                模板类定义在头文件中。模板类成员函数位于代码文件中。然后添加第三个文件，其中包含您需要的所有实例化类
                    eg: 1-2

                    “模板类”命令使编译器显式实例化模板类。
                        在上述情况下，编译器将在templates.cpp 中模版出Array<int> 和Array<double>。
                        因为 templates.cpp 在我们的项目中，所以它会被编译。然后可以从其他地方链接这些功能。
                        然后可以从其他地方链接这些功能。

                    此方法可能更有效（取决于您的编译器和链接器如何处理模板和重复定义），但需要维护每个程序的 templates.cpp 文件。
                       


默认参数：
    就像函数参数可以有默认参数一样，模板参数也可以有默认值。当模板参数未明确指定且无法推断时，将使用这些参数
        eg:6.2



类模板参数推导 (Class template argument deduction:CTAD):
    note:
        *CTAD 不适用于非静态成员初始化
            当使用非静态成员初始化来初始化类类型的成员时，CTAD 将在此上下文中不起作用。所有模板参数必须显式指定
                eg:6.3


        *CTAD 不适用于函数参数
            CTAD 代表类模板参数推导，而不是类模板参数推导，因此它只会推断出模板实参的类型，而不是模板形参的类型。在这种情况下，您应该使用模板：
                eg:6.4



别名模板(Alias templates):
    eg：6.5，6。6