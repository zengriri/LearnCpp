简介:
    当为给定类型实例化函数模板时，编译器会模版出模板化函数的副本，并将模板类型参数替换为变量声明中使用的实际类型
    这意味着特定函数对于每个实例类型将具有相同的实现细节（只是使用不同的类型）。
    虽然大多数情况下，这正是您想要的，但在某些情况下，为特定数据类型实现稍有不同的模板化函数很有用。

    eg:
        3-1
        当我们分配 Storage<char*> 类型的变量时，将使用此构造函数而不是默认构造函数。结果，m_value 将收到它自己的字符串副本。因此，当我们删除字符串时，m_value 将不受影响。

        这样，当 Storage<char*> 类型的变量超出范围时，在专用构造函数中分配的内存将在专用析构函数中被删除。
            然而，也许令人惊讶的是，上述专门的析构函数不会编译。这是因为一个专门化的函数必须专门化一个显式函数（不是编译器为其提供默认值的函数）。
            由于我们没有在 Storage<T> 中定义析构函数，编译器为我们提供了默认析构函数，因此我们无法提供专门化。为了解决这个问题，我们必须在 Storage<T> 中显式定义一个析构函数

     template <> 告诉编译器这是一个模板函数，但没有模板参数（因为在这种情况下，我们明确指定了所有类型）。
     一些编译器可能允许你省略它，但包含它是正确的。