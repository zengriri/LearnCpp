
*概述：
    当数据的所有权从一个对象转移到另一个对象时，我们说数据已被移动。这种移动的成本通常是微不足道的（通常只是两个或三个指针分配，这比复制数据数组快得多！）。
        调用移动语义时，将移动任何可移动的数据成员，并复制任何不可移动的数据成员。移动数据而不是复制数据的能力可以使移动语义比复制语义更有效，特别是当我们可以用廉价的移动替换昂贵的副本时。


*How move semantics is invoked：
    通常，当使用相同类型的对象初始化对象或为其分配相同类型的对象时，将使用复制语义（假设未删除副本）。但是，当满足以下所有条件时，将调用移动语义：
        1：The type of the object supports move semantics.
        2：The initializer or object being assigned from is an rvalue (temporary) object.
        3：The move isn’t elided.

    这是一个悲伤的消息：支持移动语义的类型并不多。然而， std::vector 和 std::string 都可以！
        *我们可以按值返回可移动的类型，例如 std::vector
            因为按值返回返回右值，所以如果返回的类型支持移动语义，则可以移动返回的值，而不是将其复制到目标对象中，这使得按价值返回对于这些类型来说极其便宜！



*key insight:
    *移动语义是一种优化，它允许我们在某些情况下以廉价的方式将某些数据成员的所有权从一个对象转移到另一个对象（而不是制作更昂贵的副本）。
        无法移动的数据成员将被复制。
    
    *我们可以按值返回可移动的类型（如 std::vector 和 std::string）。此类类型将以廉价的方式移动它们的值，而不是制作昂贵的副本。此类类型仍应通过 const 引用传递。