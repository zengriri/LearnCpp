概述：  
    *复制构造函数是用于用相同类型的现有对象来初始化对象的构造函数。复制构造函数执行后，新创建的对象应该是作为初始值设定项传入的对象的副本。

    *与默认构造函数非常相似，如果您不为类提供复制构造函数，C++ 将为您创建一个公共复制构造函数。

    *因为编译器对你的类了解不多，默认情况下，创建的复制构造函数使用一种称为成员初始化的初始化方法
        成员初始化只是意味着副本的每个成员都直接从被复制的类的成员初始化

            就像我们可以显式定义默认构造函数一样，我们也可以显式定义复制构造函数。复制构造函数看起来就像你期望的那样：
                eg:3-1

    *当对象按值传递时，实参被复制到形参中。当参数和参数是相同的类类型时，通过隐式调用复制构造函数来进行复制。
        类似地，当对象按值返回给调用者时，会隐式调用复制构造函数来进行复制

    *default:
        如果一个类没有复制构造函数，编译器会隐式地为我们生成一个。如果我们愿意，我们可以显式请求编译器使用 = default 语法为我们创建一个默认的复制构造函数：

    *Using = delete to prevent copies:
        有时我们会遇到不希望某个类的对象可复制的情况。我们可以通过使用=删除语法将复制构造函数标记为已删除来防止这种情况：
            您还可以通过将复制构造函数设置为私有来防止公共复制类对象（因为公共函数无法调用私有函数）。



Prefer the implicit copy Constructors： 
    与不执行任何操作（因此很少是我们想要的）的隐式默认构造函数不同，隐式复制构造函数执行的成员初始化通常正是我们想要的。因此，在大多数情况下，使用隐式复制构造函数是完全可以的。


Best practice：
    *首选隐式复制构造函数，除非您有特定原因需要创建自己的复制构造函数。
    *如果您编写自己的复制构造函数，则参数应该是 const 左值引用。


note:
    *访问控制在每个类的基础上工作（而不是在每个对象的基础上）。这意味着类的成员函数可以访问相同类型的任何类对象（不仅仅是隐式对象）的私有成员。
        因此可以访问私有成员，并将其copy过去。

    *复制构造函数的参数必须是引用
        要求复制构造函数的参数是左值引用或 const 左值引用。由于复制构造函数不应修改参数，因此首选使用 const 左值引用。
    
    *复制构造函数除了复制对象之外不应该执行任何操作。这是因为在某些情况下编译器可能会优化复制构造函数。
        故：除了复制之外，复制构造函数不应该有任何副作用。

        because:复制省略是一种编译器优化技术，允许编译器删除不必要的对象复制,换句话说，在编译器通常调用复制构造函数的情况下，编译器可以自由地重写代码以避免完全调用复制构造函数。
            当编译器优化掉对复制构造函数的调用时，我们说构造函数已被省略。如果编译器省略对复制构造函数的调用，则副作用将不会执行，并且程序的可观察行为将会改变！

        Mandatory copy elision in C++17:
            在 C++17 之前，复制省略严格来说是编译器可以进行的可选优化.在 C++17 中，复制省略在某些情况下成为强制性的。在这些情况下，复制省略将自动执行（即使您告诉编译器不要执行复制省略）。





