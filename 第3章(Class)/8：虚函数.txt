用于基类的指针和引用：
    在没有虚函数的情况下:
        eg: 8-1

        在类似 8-1 情况下，我们都遇到了基指针或引用只能调用函数的基版本，而不是派生版本的问题。
        因此，我们将以下展示如何使用虚函数来解决这个问题。

虚函数和多态:
    虚函数是一种特殊类型的函数，当被调用时，它会解析为存在于基类和派生类之间的函数的最派生版本。这种能力称为多态性
    如果派生函数具有与函数的基本版本相同的签名（名称、参数类型以及是否为 const）和返回类型，则认为派生函数是匹配的。此类函数称为覆盖(overrides)。
    要使函数成为虚拟函数，只需将“virtual”关键字放在函数声明之前。
        eg:8-2


不要从构造函数或析构函数调用虚函数: 
    这是另一个经常抓住毫无戒心的新程序员的陷阱。您不应该从构造函数或析构函数调用虚函数。
    why?
        请记住，在创建 Derived 类时，首先构造 Base 部分
        如果你要从 Base 构造函数调用一个虚函数，而类的 Derived 部分甚至还没有创建，
        它将无法调用函数的派生版本，因为派生函数没有派生对象可以处理。在 C++ 中，它将改为调用 Base 版本。

        析构函数也存在类似问题
            如果您在基类析构函数中调用虚函数，它将始终解析为该函数的基类版本，因为该类的派生部分已经被销毁。


    建议：
        永远不要从构造函数或析构函数调用虚函数



override 和 final 说明符，以及协变返回类型：
    override:
        因为使用覆盖说明符没有性能损失，它有助于确保您实际上覆盖了您认为拥有的功能,所有虚拟覆盖函数都应使用覆盖说明符进行标记。
        此外，由于覆盖说明符意味着虚拟，因此无需使用带有 virtual 关键字的覆盖说明符来标记函数。

        最佳实践:
            在基类中的虚函数上使用 virtual 关键字。在派生类中的覆盖函数上使用覆盖说明符（但不是 virtual 关键字）。

        eg： 8-3

    final：
        在某些情况下，您可能不希望某人能够覆盖虚函数或从类继承。 final 说明符可用于告诉编译器强制执行此操作。
        如果用户试图覆盖一个函数或从一个已指定为 final 的类继承，编译器将给出编译错误

        eg:8-4,8-5


    协变返回类型:
        有一种特殊情况，派生类虚函数覆盖可以具有与基类不同的返回类型，但仍被视为匹配覆盖
        如果虚函数的返回类型是指针或类的引用，覆盖函数可以返回指针或派生类的引用,这些称为协变返回类型

        eg:8-6


Virtual destructors, virtual assignment, and overriding virtualization:
    Virtual destructors:
        尽管 C++ 为您的类提供了一个默认析构函数（如果您自己不提供），但有时您会想要提供自己的析构函数（特别是如果类需要释放内存）。
        如果你正在处理继承，你应该总是让你的析构函数是虚拟的。
            eg:8-7

            我们真的希望delete函数调用Derived的析构函数（会依次调用Base的析构函数），否则m_array不会被删除。我们通过将 Base 的析构函数设为虚拟来做到这一点：
                eg:8-8

        *注：
            无论何时处理继承，都应该使任何显式析构函数成为虚拟的

            请注意，如果您希望您的基类有一个空的虚拟析构函数，您可以这样定义您的析构函数
                eg:
                    virtual ~Base() = default; // generate a virtual default destructor


        *与普通的虚成员函数一样，如果基类函数是虚函数，则所有派生的覆盖都将被视为虚函数，无论它们是否被指定为虚函数。不必创建一个空的派生类析构函数来将其标记为虚拟。
    
    Virtual assignment:
        可以将赋值运算符设为虚拟。

    Ignoring virtualization：
        很少你可能想忽略一个函数的虚拟化：
            eg:8-9



我们应该把所有的析构函数都变成虚拟的吗？
    如果未将基类析构函数标记为虚拟，则如果程序员稍后删除指向派生对象的基类指针，则程序将面临内存泄漏的风险。

    避免这种情况的一种方法是将所有析构函数标记为虚拟。但是你应该吗？
        很容易说是，这样你以后就可以使用任何类作为基类——但是这样做会降低性能（一个虚拟指针添加到你的类的每个实例）。因此，您必须平衡成本以及您的意图。

    传统观点（最初由备受推崇的 C++ 大师 Herb Sutter 提出）建议避免非虚拟析构函数内存泄漏情况，如下所示:
        “基类析构函数应该是公共的和虚拟的，或者是受保护的和非虚拟的。”
            具有受保护析构函数的类不能通过指针删除，从而防止在基类具有非虚拟析构函数时通过基指针意外删除派生类。
            不幸的是，这也意味着不能通过基类指针删除基类，这实质上意味着除了派生类之外不能动态分配或删除该类。
            这也排除了对此类类使用智能指针（例如 std::unique_ptr 和 std::shared_ptr），这限制了该规则的有用性（我们将在后面的章节中介绍智能指针）
            这也意味着不能在堆栈上分配基类。这是一套相当重的处罚。

    我们的建议如下：
        *如果您打算继承您的类，请确保您的析构函数是虚拟的。
        *如果您不打算继承您的类，请将您的类标记为 final。这将首先防止其他类从它继承，而不会对类本身施加任何其他使用限制。



