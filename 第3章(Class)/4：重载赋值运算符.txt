赋值与复制构造函数：
    *复制构造函数和赋值运算符的目的几乎是等价的。两者都将一个对象复制到另一个对象。但是，复制构造函数初始化新对象，而赋值运算符替换现有对象的内容。

    *与其他运算符不同，如果您不提供，编译器将为您的类提供默认的公共赋值运算符
        此赋值运算符进行成员赋值（这与默认复制构造函数所做的成员初始化基本相同）。

        就像其他构造函数和运算符一样，您可以通过将赋值运算符设为私有或使用 delete 关键字来防止进行赋值：

    *区别：
        如果在复制之前必须创建一个新对象，则使用复制构造函数（注意：这包括按值传递或返回对象）。

        如果在复制之前不必创建新对象，则使用赋值运算符。

        


重载赋值运算符：
    重载赋值运算符 (operator=) 相当简单，我们将要注意一个特定的警告。赋值运算符必须作为成员函数重载。

    eg: 5-1


浅Vs深度复制:
    *因为 C++ 对您的类了解不多，所以它提供的默认复制构造函数和默认赋值运算符使用称为成员复制（也称为浅复制）的复制方法。
        这意味着 C++ 单独复制类的每个成员（对重载的 operator= 使用赋值运算符，对复制构造函数使用直接初始化）。.当类很简单（例如，不包含任何动态分配的内存）时，这非常有效。

        编译器为此类提供的默认复制构造函数和默认赋值运算符 
            eg:5-2
                请注意，因为这些默认版本可以很好地复制这个类，所以在这种情况下，真的没有理由编写我们自己的这些函数版本。
                然而，在设计处理动态分配内存的类时，成员（浅）复制会给我们带来很多麻烦！
                这是因为指针的浅拷贝只是复制指针的地址——它不分配任何内存或复制指向的内容！


        
    *深拷贝:
        对任何被复制的非空指针进行深度复制。深拷贝为拷贝分配内存，然后拷贝实际值，这样拷贝就存在于与源不同的内存中。
        这样，副本和来源是不同的，不会以任何方式相互影响。进行深拷贝需要我们编写自己的拷贝构造函数和重载赋值运算符

    *更好的解决方案:
        标准库中处理动态内存的类，例如 std::string 和 std::vector，处理它们的所有内存管理，并具有重载的复制构造函数和赋值运算符，可以进行适当的深度复制。
        因此，您可以像普通的基本变量一样初始化或分配它们，而不是自己进行内存管理！
        这使这些类更易于使用，更不容易出错，并且您不必花时间编写自己的重载函数！


    *概括
        默认复制构造函数和默认赋值运算符执行浅拷贝，这对于不包含动态分配变量的类来说很好。

        具有动态分配变量的类需要具有执行深度复制的复制构造函数和赋值运算符。

        倾向于使用标准库中的类而不是自己进行内存管理。


