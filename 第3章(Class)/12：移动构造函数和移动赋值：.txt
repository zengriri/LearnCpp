复制构造函数和复制赋值：
    复制构造函数用于通过复制同一类的对象来初始化类。复制赋值用于将一个类对象复制到另一个现有的类对象。
        默认情况下，如果没有明确提供，C++ 将提供一个复制构造函数和复制赋值运算符。
        这些编译器提供的函数执行浅拷贝，这可能会导致分配动态内存的类出现问题。所以处理动态内存的类应该重写这些函数来做深拷贝。

        eg:12-1
            所以，简而言之，因为我们调用了一次复制构造函数来将构造 res 复制到一个临时对象，并复制一次赋值以将临时对象复制到 mainres，所以我们最终总共分配和销毁了 3 个单独的对象。
            效率低下，但至少不会崩溃！然而，有了移动语义，我们可以做得更好。

移动语义背后的关键见解：    
    C++11 通过 r-value 引用，让我们能够在参数是 r-value 和 l-value 时提供不同的行为，使我们能够就对象的行为方式做出更智能、更有效的决策。


移动构造函数和移动赋值：
    C++11 定义了两个为移动语义服务的新函数：移动构造函数和移动赋值运算符。
    鉴于复制构造函数和复制赋值的目标是将一个对象复制到另一个对象，移动构造函数和移动赋值的目标是将资源的所有权从一个对象转移到另一个对象（这通常比制作副本便宜得多）。

    移动构造函数和移动赋值运算符很简单。我们不是将源对象 (a) 深度复制到隐式对象中，而是简单地移动（窃取）源对象的资源。
        这涉及将源指针浅复制到隐式对象中，然后将源指针设置为空。

    定义移动构造函数和移动赋值的工作类似于它们的复制对应物
        然而，虽然这些函数的复制风格采用 const 左值引用参数，但这些函数的移动风格使用非 const 右值引用参数。

     eg:12-2


     何时调用移动构造函数和移动赋值？
        *移动构造函数和移动赋值在这些函数被定义后被调用，构造或赋值的参数是一个右值。最典型的是，这个右值将是一个文字或临时值。
            在大多数情况下，移动构造函数和移动赋值运算符默认是不提供的，除非该类没有任何定义的复制构造函数、复制赋值、移动赋值或析构函数

        *C++ 规范有一个特殊规则，即从函数按值返回的自动对象即使是左值也可以移动
            这是有道理的，因为 res 无论如何都会在函数结束时被销毁！我们不妨窃取它的资源，而不是制作昂贵且不必要的副本。


禁用copy:
    在启用移动的类中，有时需要删除复制构造函数和复制赋值函数以确保不进行复制。
        如果您尝试将左值按值传递给函数，编译器会抱怨初始化函数参数所需的复制构造函数已被删除。
        eg:12-3


std::move:
    在 C++11 中，std::move 是一个标准库函数，它将（使用 static_cast）其参数转换为右值引用，以便可以调用移动语义。
        因此，我们可以使用 std::move 将左值转换为更喜欢被移动而不是被复制的类型。 std::move 在utility头中定义。
            eg:12-4,12-5

std::move_if_noexcept():
    如果对象具有 noexcept 移动构造函数，std::move_if_noexcept 将返回一个可移动的右值，否则它将返回一个可复制的左值
        我们可以将 noexcept 说明符与 std::move_if_noexcept 结合使用，以仅在存在强异常保证时使用移动语义（否则使用复制语义）。

    如果编译器可以判断作为参数传递给 std::move_if_noexcept 的对象在移动构造时不会抛出异常（或者如果对象是仅移动且没有复制构造函数），
        则 std::move_if_noexcept 将执行与 std::move() 相同的操作（并返回转换为 r 值的对象）。
        否则， std::move_if_noexcept 将返回对该对象的正常左值引用。

