*概述:
    析构函数是另一种特殊类型的类成员函数，当该类的对象被销毁时执行。构造函数旨在初始化类，而析构函数旨在帮助清理。
        当对象正常地超出作用域，或者使用delete关键字显式地删除动态分配的对象时，将自动调用类析构函数(如果存在)，以便在从内存中删除对象之前进行必要的清理。
        对于简单类(那些只初始化普通成员变量值的类)，不需要析构函数，因为c++会自动为您清理内存。
        然而，如果你的类对象持有任何资源(例如动态内存，或文件或数据库句柄)，
        或者如果你需要在对象被销毁之前做任何类型的维护，析构函数是做这些的完美地方，因为它通常是在对象被销毁之前发生的最后一件事。

*析构函数命名
    1:析构函数必须与类同名，前面有波浪号 (~)
    2:析构函数不能接受参数
    3:析构函数没有返回类型


*一个类只能有一个析构函数:
    一般来说，您不应该显式调用析构函数（因为当对象被销毁时它将自动调用），因为很少有您想要多次清理对象的情况。
        但是，析构函数可以安全地调用其他成员函数，因为直到析构函数执行后对象才会被销毁。

        eg：13.1

*RAII：
    RAII(资源获取即初始化)是一种编程技术，通过这种技术，资源使用与具有自动持续时间的对象的生命周期(例如，非动态分配对象)相关联。
        在c++中，RAII是通过带有构造函数和析构函数的类实现的。资源(如内存、文件或数据库句柄等)通常在对象的构造函数中获取(尽管如果有意义，也可以在对象创建后获取)。
        然后，该资源可以在对象处于活动状态时使用。当对象被销毁时，在析构函数中释放资源。RAII的主要优点是它有助于防止资源泄漏(例如，内存不会被释放)，
        因为所有占用资源的对象都会自动清理。

    总之:在构造函数中分配，在析构函数中释放。 
        std::string 和 std::vector 是标准库中遵循 RAII 的类的示例——动态内存在初始化时获取，并在销毁时自动清理。




    