Constructors：
    *default Constructors：
        *如果非聚合类类型对象没有用户声明的构造函数，编译器将生成一个公共默认构造函数（以便该类可以进行值或默认初始化）。该构造函数称为隐式默认构造函数。
            隐式默认构造函数相当于没有参数、没有成员初始值设定项列表且构造函数体内没有语句的构造函数。

    *Using = default:
            如果我们编写一个与隐式生成的默认构造函数等效的默认构造函数，我们可以告诉编译器为我们生成一个默认构造函数。该构造函数称为显式默认的默认构造函数，可以使用 = default 语法生成它
            eg:
                class_name() = default
        
    * Explicitly defaulted default constructor vs empty user-defined constructor
        1：当值初始化一个类时，如果该类有用户定义的默认构造函数，则该对象将被默认初始化，
            但是，如果类具有非用户定义的默认构造函数（即，隐式定义的构造函数或使用 = default 创建的默认构造函数），则该对象将在默认初始化之前进行零初始化。
        
        2：在 C++20 之前，具有用户定义的默认构造函数的类（即使它具有空主体）使该类成为非聚合类，而显式默认的默认构造函数则不会。
            假设该类是一个聚合，则前者将导致该类使用列表初始化而不是聚合初始化。在 C++20 中，这种不一致问题得到了解决，因此两者都使类成为非聚合类。
    

   *委托构造函数：
        允许构造函数调用同一类的其他构造函数。这个过程称为委托构造函数（或构造函数链接）。
            eg:1-1

        note:
            1:首先，不允许委托给另一个构造函数的构造函数本身进行任何成员初始化。因此，您的构造函数可以委托或初始化，但不能两者兼而有之。
                所以，构造函数只能委托或初始化，而不能两者兼而有之，因此，通常将参数较少的构造函数委托给参数较多的构造函数。

            2：其次，一个构造函数可以委托给另一个构造函数，后者又委托回第一个构造函数。

    *使用默认参数减少构造函数：
        默认值有时也可用于将多个构造函数减少为更少的构造函数。


Destructors:
    *概述：
        *当非聚合类类型的对象被销毁时，该函数会自动调用。该函数称为析构函数。析构函数旨在允许类在销毁该类的对象之前进行任何必要的清理。

        *一个类只能有一个析构函数。

        *一般来说，您不应该显式调用析构函数（因为当对象被销毁时它将自动调用），因为很少有您想要多次清理对象的情况。

        *析构函数可以安全地调用其他成员函数，因为直到析构函数执行后对象才会被销毁。
            如果您的类不需要在销毁时进行任何清理，那么根本不定义析构函数就可以了，让编译器为您的类生成一个隐式析构函数。


    *隐式析构函数：
        如果非聚合类类型对象没有用户声明的析构函数，则编译器将生成一个具有空主体的析构函数。该析构函数称为隐式析构函数，它实际上只是一个占位符。

    *A warning about the std::exit() function：
        我们讨论了 std::exit() 函数，可用于立即终止程序。当程序立即终止时，程序就结束了。
            局部变量不会首先被销毁，因此不会调用析构函数。在这种情况下，如果您依赖析构函数来执行必要的清理工作，请务必小心。

        note:
            未处理的异常也会导致程序终止，并且在此之前可能不会展开堆栈。如果堆栈展开没有发生，则在程序终止之前不会调用析构函数。


    *Destructor naming：
        1：析构函数必须与类同名，前面有波浪号 (~)。
        2：析构函数不能接受参数。
        3：析构函数没有返回类型。

    *


Constructor member initializer lists:
    *成员初始化顺序：
        因为 C++ 标准是这样规定的，所以成员初始值设定项列表中的成员始终按照它们在类内部定义的顺序（而不是按照它们在成员初始值设定项列表中定义的顺序）进行初始化。
            eg:13.1

    *Member initializer list vs default member initializers:
        可以通过几种不同的方式初始化成员：
            1:如果成员初始值设定项列表中列出了某个成员，则使用该初始化值
            2:否则，如果该成员具有默认成员初始值设定项，则使用该初始化值
            3:否则，该成员将被默认初始化。


    note:
        *优先使用成员初始值设定项列表来初始化成员，而不是在构造函数主体中赋值

Converting constructors:=
    *编译器会查看我们是否定义了一些可用于执行此类转换的函数。这样的函数称为用户定义的转换。

    *The explicit keyword:
        *使用explicit关键字告诉编译器构造函数不应该用作转换构造函数,显式构造函数有两个显着的后果：
            1:显式构造函数不能用于执行复制初始化或复制列表初始化。
            2:显式构造函数不能用于执行隐式转换（因为这使用复制初始化或复制列表初始化）。

        *显式构造函数可用于直接和直接列表初始化

        *按值返回和显式构造函数:
            当我们从函数返回一个值时，如果该值与函数的返回类型不匹配，就会发生隐式转换。就像按值传递一样，此类转换不能使用显式构造函数。

        eg:13.2

    *使用显式的最佳实践:


    *note:
        *只能应用一种用户定义的转换(不能进行2次以上的转换)

Temporary class objects：
    1：首先，就像 int 的情况一样，当在表达式中使用时，临时类对象是右值。因此，此类对象只能在接受右值表达式的情况下使用。
    2：其次，临时对象在定义时创建，并在定义它们的完整表达式结束时销毁。完整表达式是不是子表达式的表达式。


The hidden “this” pointer:


explicit:
    关键字explicit明确构造函数（和转换函数）不能进行隐式转换，该关键字位于函数名称的前面。
        eg:1-2

delete:
    使用“delete”关键字删除函数.当一个函数被删除时，对该函数的任何使用都被认为是编译错误。
    请注意，也可以删除复制构造函数和重载运算符，以防止使用这些函数
    eg:1-3


 三法则:    
    复制构造函数(copy constructor), 析构函数(destructor), 复制赋值运算符(copy assignment operator)

五法则:
    在三法则基础上，额外添加 移动构造函数(move constructor)和移动赋值运算符(move assignment operator) 


Memeber function:

    const:
        *const 成员函数是保证不会修改对象或调用任何非 const 成员函数（因为它们可能会修改对象）的成员函数。
            对于在类定义外部定义的成员函数，必须在类定义中的函数声明和类定义外部的函数定义上使用 const 关键字。

        *可以重载成员函数以获得同一函数的 const 和非 const 版本.
            这是有效的，因为 const 限定符被认为是函数签名的一部分，因此两个仅在 const 性上不同的函数被认为是不同的


    返回值：
        1：使用通过引用安全返回的成员函数
        2：不要“保存”返回的引用以供以后使用，除非您确定隐式对象是左值。如果您使用右值隐式对象执行此操作，则当您使用现在悬空的引用时，将导致未定义的行为
        3：如果您确实需要保留返回的引用以供以后使用，并且不确定隐式对象是否是左值，请使用返回的引用作为非引用局部变量的初始值设定项，这会将被引用的成员复制到局部变量中
        4：不要返回对私有数据成员的非常量引用，因为引用的行为就像被引用的对象一样，所以返回非常量引用的成员函数提供了对该成员的直接访问（即使该成员是私有的）
        5：Const 成员函数不能返回对数据成员的非常量引用

    note:
        *成员函数如果定义在类类型定义中，则默认隐式内联的，因此，如果类类型定义include在多个代码文件中，它们不会导致违反单一定义规则。

        *const 对象不能调用非 const 成员函数

        *C++编译器通常从上到下编译代码。对于遇到的每个名称，编译器都会确定它是否已经看到该名称的声明，以便可以进行正确的类型检查。
            但是，对于成员函数（和成员数据初始值设定项），此限制不适用，我们可以按照我们喜欢的任何顺序定义成员。

        *因为 C++ 标准是这样规定的，所以成员初始值设定项列表中的成员始终按照它们在类内部定义的顺序（而不是按照它们在成员初始值设定项列表中定义的顺序）进行初始化


Class code and header files:
    传统上，类定义放在与类同名的头文件中，在类外定义的成员函数放在与类同名的.cpp文件中。

        在头文件中定义类不违反单定义规则吗？
            *当然不会。如果你的头文件有适当的头保护，就不可能在同一个文件中多次包含类定义。
            *类型（包括类）不受单一定义规则的约束，即每个程序只能有一个定义。因此，不存在 #include 类定义到多个代码文件中的问题（如果有，类就没有多大用处）。

        在头文件中定义成员函数不违反单定义规则吗？
            *这取决于。在类定义中定义的成员函数被认为是隐式内联的。
                内联函数不受单一定义规则的每个程序部分单一定义的约束。这意味着在类定义本身中定义普通的成员函数（例如访问函数）没有问题。

            *在类定义之外定义的成员函数被视为普通函数，并且受单一定义规则的每个程序部分一个定义的约束。
                因此，这些函数应该在代码文件中定义，而不是在头文件中。一个例外是模板函数

        那么我应该在头文件和 cpp 文件中定义什么，以及在类定义内部和外部定义什么？
            您可能很想将所有成员函数定义放入类内部的头文件中。虽然这将编译，但这样做有几个缺点：
                *首先，如上所述，这会使您的类定义变得混乱。
                *其次，如果您更改标头中的代码，则需要重新编译包含该标头的每个文件
                    这可能会产生连锁反应，其中一个微小的更改会导致整个程序需要重新编译（这可能很慢）。如果您更改 .cpp 文件中的代码，则只需重新编译该 .cpp 文件！

            那么我应该在头文件和 cpp 文件中定义什么，以及在类定义内部和外部定义什么？
                我们建议如下：
                            *对于仅在一个文件中使用且通常不可重用的类，请直接在使用它们的单个 .cpp 文件中定义它们。
                            *对于在多个文件中使用的类，或用于一般重用的类，请在与该类同名的 .h 文件中定义它们。
                            *普通成员函数（普通构造函数或析构函数、访问函数等）可以在类中定义。
                            *重要的成员函数应在与类同名的 .cpp 文件中定义。

        默认参数：
            成员函数的默认参数应该在类定义（在头文件中）中声明，任何人都可以在其中看到它们#includes header。


