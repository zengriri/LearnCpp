*概述：
    大多数情况下，类是在与类同名的头文件(.h)中定义的，并且在类外部(.cpp)定义的任何成员函数都放在与类同名的 .cpp 文件中。
        简单的成员函数（例如访问函数、具有空主体的构造函数等）可以在类定义中定义

*ODR:
    类型不受单一定义规则 (ODR) 的约束，该规则规定每个程序只能有一个定义。因此，将类定义包含(#include)到多个翻译单元中不存在问题。如果有的话，则类就没多大用处了。
        
     note:
        将类定义多次包含到单个翻译单元中仍然是 ODR 违规。但是，标头防护（或 #pragma 一次）将防止这种情况发生。


*Default arguments for member functions:
    由于成员函数始终被声明（或定义）为类定义的一部分，因此成员函数的最佳实践实际上更简单：始终将默认参数放在类定义中

    Best practice:
        将成员函数的所有默认参数放在类定义中。


*Inline member functions：
    *成员函数不能免除 ODR，因此您可能想知道当在头文件中定义成员函数（然后可能会包含到多个翻译单元中）时，我们如何避免 ODR 违规。

    *类定义中定义的成员函数是隐式内联的。内联函数不受“ODR”规则的“每个程序一个定义”部分的约束。
        在类定义之外定义的成员函数不是隐式内联的（因此受“ODR”规则的“每个程序一个定义”部分的约束）。
        这就是为什么此类函数通常在代码文件中定义（在整个程序中它们只有一个定义）. 或者，如果类定义之外定义的成员函数是内联的（使用 inline 关键字），则可以将其保留在头文件中。

    *note:
        类定义中定义的函数是隐式内联的，这使得它们可以#included 到多个代码文件中，而不会违反 ODR。
        在类定义之外定义的函数不是隐式内联的。可以使用 inline 关键字将它们内联。


*Inline expansion of member functions
    编译器必须能够看到函数的完整定义才能执行内联扩展。大多数情况下，此类函数（例如访问函数）是在类定义中定义的。
        但是，如果您想在类定义之外定义成员函数，但仍希望它能够进行内联扩展，则可以将其定义为类定义下方的内联函数（在同一头文件中（.h））,
        这样，任何 #includes 标头的人都可以访问该函数的定义。


*在某些情况下，违反将类定义放在标头中并将重要成员函数放在代码文件中的最佳实践可能是有意义的。
    1:对于仅在一个代码文件中使用且不打算进行一般重用的小类，您可能更愿意直接在使用该类的单个 .cpp 文件中定义该类（以及所有成员函数）。
    2:如果一个类只有少量不太可能更改的重要成员函数，则创建仅包含一两个定义的 .cpp 文件可能不值得付出努力（因为它会使您的项目变得混乱）。
        在这种情况下，最好使成员函数内联并将它们放置在标头中的类定义下方。
    3:在现代 C++ 中，类或库越来越多地以“仅头文件”的形式分发，这意味着类或库的所有代码都放置在头文件中。
        这样做主要是为了使分发和使用此类文件更容易，因为标头只需要#included，而代码文件需要显式添加到使用它的每个项目中，以便可以编译它。
        如果有意创建仅包含头文件的类或库进行分发，则可以将所有重要的成员函数内联并放置在类定义下的头文件中。
    4:最后，对于模板类，在类外部定义的模板成员函数几乎总是在头文件内定义，位于类定义之下.就像非成员模板函数一样，编译器需要查看完整的模板定义才能实例化它。
    

*Nested types (member types):
    *类类型支持另一种成员：嵌套类型（也称为成员类型）
        要创建嵌套类型，您只需在类内部的适当访问说明符下定义该类型即可

    *嵌套类型 Type 已在类的顶部定义。嵌套类型名称必须在使用之前完全定义，因此通常首先定义它们。
        Best practice:
            在类类型的顶部定义任何嵌套类型。

    *Nested typedefs and type aliases:
        类类型还可以包含嵌套的 typedef 或类型别名

    *嵌套类和对外部类成员的访问:
        类将其他类作为嵌套类型的情况相当罕见，但这是可能的.
            在C++中，嵌套类无法访问外部（包含）类的this指针，因此嵌套类不能直接访问外部类的成员。 这是因为嵌套类可以独立于外部类进行实例化（在这种情况下，将没有外部类成员可以访问！）.
            但是，由于嵌套类是外部类的成员，因此它们可以访问范围内的外部类的任何私有成员。
        eg: 
            15.9

    *嵌套类型不能向前声明
        嵌套类型还有一个值得一提的限制——嵌套类型不能向前声明。此限制可能会在 C++ 的未来版本中取消。
    
       
*Libraries:
    在整个程序中，您使用了标准库中的类，例如 std::string。要使用这些类，您只需#include 相关标头（例如#include <string>）。
        请注意，您不需要将任何代码文件（例如 string.cpp 或 iostream.cpp）添加到项目中。 头文件提供编译器所需的声明，以验证您正在编写的程序在语法上是否正确.
        但是，属于 C++ 标准库的类的实现包含在预编译文件中，该文件在链接阶段自动链接。你永远不会看到代码。

    许多开源软件包都提供 .h 和 .cpp 文件供您编译到程序中。但是，大多数商业库仅提供 .h 文件和预编译库文件。
        reasons:
            1:链接预编译库比每次需要时重新编译它更快
            2:预编译库的单个副本可以由许多应用程序共享，而编译后的代码会编译到使用它的每个可执行文件中（膨胀文件大小）
            3:知识产权原因（您不希望人们窃取您的代码）。

        
*Class templates with member functions:
    *定义为类模板参数声明一部分的类型模板参数既可以用作数据成员的类型，也可以用作成员函数参数的类型。
        note：
            当我们在类模板定义中定义成员函数时，不需要为该成员函数提供模板参数声明。此类成员函数隐式使用类模板参数声明。

    *由于此成员函数定义与类模板定义是分开的，因此我们需要重新提供模板参数声明 (template <typename T>)，以便编译器知道 T 是什么。

    *在类外部哪里定义类模板的成员函数：
        对于类模板的成员函数，编译器需要查看类定义(以确保成员函数模板被声明为类的一部分)和模板成员函数定义(以知道如何实例化模板)。因此，我们通常希望在同一位置定义类及其成员函数模板。
        当在类定义内部定义成员函数模板时，模板成员函数定义是类定义的一部分，因此在可以看到类定义的任何地方，也可以看到模板成员函数定义。这使事情变得简单(代价是使我们的类定义变得混乱)。
        当成员函数模板在类定义之外定义时，它通常应该在类定义的下面定义。这样，在任何可以看到类定义的地方，也可以看到紧邻类定义下面的成员函数模板定义。
        在类在头文件中定义的典型情况下，这意味着类外部定义的任何成员函数模板也应在同一头文件中定义，位于类定义下方。

    Best practice:
        在类定义之外定义的任何成员函数模板都应定义在类定义的正下方（在同一文件中）


*Static member variables:
    *与普通成员变量不同，静态成员变量由类的所有对象共享。
        尽管您可以通过类的对象访问静态成员，但即使没有实例化类的对象，静态成员也存在！
        本质上，静态成员是存在于类的作用域区域内的全局变量。类的静态成员和命名空间内的普通变量之间几乎没有区别
    
    *由于静态成员 s_value 独立于任何类对象而存在，因此可以使用类名和范围解析运算符直接访问它

    *Defining and initializing static member variables:
        当我们在类类型中声明静态成员变量时，我们告诉编译器静态成员变量的存在，但实际上并没有定义它（很像前向声明）。
        由于静态成员变量本质上是全局变量，因此必须在类外部的全局范围内显式定义（并可选择初始化）静态成员。

        eg:
            int Something::s_value{ 1 }; 

            该行有两个用途：
                1:实例化静态成员变量（就像全局变量一样）并初始化它。如果未提供初始值设定项，静态成员变量默认为零初始化。
                2: 请注意，此静态成员定义不受访问控制：即使该值在类中声明为私有（或受保护），您也可以定义和初始化该值。


    *如果类是在头文件 (.h) 中定义的，则静态成员定义通常放置在该类的关联代码文件中(*.cpp)
        如果类是在源 (.cpp) 文件中定义的，则静态成员定义通常直接放置在类的下面。
        不要将静态成员定义放在头文件中（就像全局变量一样，如果该头文件被包含多次，您最终将得到多个定义，这将导致链接器错误）

        note:
            1:当静态成员是常量整型（包括 char 和 bool）或常量枚举时，可以在类定义内部初始化静态成员：
                eg:
                    class Whatever
                    {
                    public:
                        static const int s_value{ 4 }; // a static const int can be defined and initialized directly
                    };     

            2:inline,constexpr也可以在类定义内部初始化


        Best practice:
            使静态成员内联或 constexpr，以便可以在类定义内初始化它们。


    *auto and CTAD：
        静态成员可以使用 auto 从初始值设定项推断其类型，或使用类模板参数推导 (CTAD) 从初始值设定项推断模板类型参数。
            note:
                非静态成员不得使用 auto 或 CTAD。


*Static member functions:
    *由于静态成员函数不与特定对象关联，因此可以使用类名和作用域解析运算符直接调用它们. 
        与静态成员变量一样，它们也可以通过类类型的对象来调用，尽管不推荐这样做

    *Static member functions have no *this pointer
        静态成员函数有两个值得注意的有趣怪癖:
            1:他们没有 this 指针！
                仔细想想，这是有道理的——this 指针总是指向成员函数正在处理的对象.静态成员函数不适用于对象，因此不需要 this 指针。
            2:静态成员函数可以直接访问其他静态成员（变量或函数），但不能访问非静态成员.
                这是因为非静态成员必须属于类对象，而静态成员函数没有类对象可以使用！


    *Static members defined outside the class definition
        静态成员函数也可以在类声明之外定义。这与普通成员函数的工作方式相同。

    *C++不支持静态构造函数




    