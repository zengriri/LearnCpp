继承链的构造顺序：
    *C++ 分阶段构造派生类，从最基类（在继承树的顶部）开始，到最子类（在继承树的底部）结束。在构造每个类时，会调用该类的适当构造函数来初始化该类的该部分。

    *在构造派生类时，派生类构造函数负责确定调用哪个基类构造函数。如果未指定基类构造函数，则将使用默认的基类构造函数。
        在这种情况下，如果找不到（或默认创建）默认基类构造函数，编译器将显示错误。然后按照从最基础到最派生的顺序构造这些类。


不同类型的继承及其对访问的影响：
    *public：
        当您公开继承基类时，继承的公共成员保持公开，继承的受保护成员保持受保护
        继承的私有成员，因为它们在基类中是私有的而无法访问，仍然无法访问。
            eg:7-1

    *Protected：
        使用受保护的继承，公共和受保护成员受到保护，而私有成员保持不可访问。

    *Private:
        使用私有继承，基类中的所有成员都作为私有继承。这意味着私有成员不可访问，而受保护和公共成员变为私有成员。
            eg：7-2


调用继承的函数和覆盖行为：
    *在基类中定义为私有的函数可以在派生类中重新定义为公有，反之亦然！
        eg：7-3

隐藏继承的功能:
    C++ 使我们能够在派生类中更改继承成员的访问说明符。这是通过使用 using 声明来标识（范围）基类成员在派生类中更改其访问权限的新访问说明符下完成的。
        eg：7-4
    
    隐藏功能:
        在 C++ 中，除了修改源代码之外，无法从基类中删除或限制功能。但是，在派生类中，可以隐藏基类中存在的功能，使其无法通过派生类访问。
        这可以简单地通过更改相关的访问说明符来完成。
            eg:7-5

        您可以在派生类中将成员函数标记为已删除，以确保它们根本无法通过派生对象调用:
            eg：7-6


多重继承：
    C++ 提供了进行多重继承的能力。多重继承使派生类能够从多个父类继承成员。
        eg:7-7

    多重继承的问题:
        虽然多重继承似乎是单继承的简单扩展，但多重继承引入了许多问题，这些问题会显着增加程序的复杂性，并使它们成为维护的噩梦
            *首先，当多个基类包含同名函数时，可能会产生歧义
                eg：7-8
            *其次，更严重的是钻石问题，你的作者喜欢称之为“厄运钻石”。当一个类乘法继承自两个类，而这两个类又继承自一个基类时，就会发生这种情况。这导致了菱形继承模式
                虽然这些问题中的大多数可以通过明确的范围界定来解决，但是为了处理增加的复杂性而添加到类中的维护开销可能会导致开发时间飞速增长

    多重继承比它的价值更麻烦吗？
        事实证明，大多数可以使用多继承解决的问题也可以使用单继承来解决.
        许多面向对象的语言（例如 Smalltalk、PHP）甚至不支持多重继承.许多相对现代的语言，如 Java 和 C# 将类限制为普通类的单继承，但允许接口类的多继承

    建议：
        避免多重继承，除非替代方案导致更复杂
