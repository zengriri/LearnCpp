纯虚拟（抽象）函数和抽象基类：
    *C++ 允许您创建一种特殊的虚函数，称为纯虚函数（或抽象函数），它根本没有实体！纯虚函数只是充当一个占位符，意在由派生类重新定义
    *要创建一个纯虚函数，而不是为函数定义一个主体，我们只需为函数赋值 0。

    *使用纯虚函数有两个主要后果：
        1:首先，任何具有一个或多个纯虚函数的类都成为抽象基类，这意味着它不能被实例化
        2:其次，任何派生类都必须为此函数定义一个主体，否则该派生类也将被视为抽象基类

    *带有实体的纯虚函数:
        eg:11-1

        在这种情况下，speak() 仍然被认为是一个纯虚函数，因为“=0”（即使它已经被赋予了一个主体）并且 Animal 仍然被认为是一个抽象基类（因此不能被实例化）。
        任何从 Animal 继承的类都需要为 speak() 提供自己的定义，否则它也将被视为抽象基类。

        为纯虚函数提供主体时，必须单独提供主体（而不是内联）。


接口类:
    接口类是没有成员变量的类，并且所有函数都是纯虚拟的！换句话说，类纯粹是一个定义，并没有实际的实现
    当您想要定义派生类必须实现的功能时，接口很有用，但将派生类如何实现该功能的细节完全留给派生类。
        eg:11-2

纯虚函数和虚表:
    抽象类仍然具有虚拟表，因为如果您有抽象类的指针或引用，它们仍然可以使用
    如果没有提供覆盖，纯虚函数的虚表条目通常要么包含一个空指针，要么指向一个打印错误的通用函数（有时这个函数被命名为 __purecall）。


虚拟基类:
    要共享一个基类，只需在派生类的继承列表中插入“virtual”关键字。这将创建所谓的虚拟基类，这意味着只有一个基对象
    这意味着只有一个基础对象。基础对象在继承树中的所有对象之间共享，并且只构造一次。
        eg:11-3


dynamic_cast:
    *C++ 提供了一个名为 dynamic_cast 的强制转换运算符.
        尽管动态转换有一些不同的功能，但到目前为止，动态转换最常见的用途是将基类指针转换为派生类指针。这个过程称为向下转换。

    *如果 dynamic_cast 失败，转换的结果将是一个空指针

    *规则:
        始终通过检查空指针结果来确保您的动态转换确实成功。

    *在某些情况下使用 dynamic_cast 向下转换不起作用：
        1：具有受保护或私有继承。
        2:对于不声明或继承任何虚函数的类（因此没有虚表）。
        3:在某些涉及虚拟基类的情况下

    *dynamic_cast and references:
        尽管上述所有示例都显示了指针的动态转换（更常见），但 dynamic_cast 也可以与引用一起使用。
        
        因为 C++ 没有“空引用”，dynamic_cast 在失败时不能返回空引用。相反，如果引用的 dynamic_cast 失败，则会抛出 std::bad_cast 类型的异常。


static_cast:    
    使用 static_cast 向下转换
        *事实证明，向下转换也可以用 static_cast 完成。主要区别在于 static_cast 不进行运行时类型检查以确保您所做的事情是有意义的。
            这使得使用 static_cast 更快，但更危险。如果将 Base* 转换为 Derived*，即使 Base 指针未指向 Derived 对象，它也会“成功”。
            .当您尝试访问生成的 Derived 指针（实际上是指向 Base 对象）时，这将导致未定义的行为。

        *如果您绝对确定向下转换的指针会成功，那么使用 static_cast 是可以接受的。
            确保您知道所指向的对象类型的一种方法是使用虚函数。


dynamic_cast vs static_cast:
    新程序员有时会对何时使用 static_cast 和 dynamic_cast 感到困惑。答案很简单：
        除非你正在向下转换，否则使用 static_cast，在这种情况下 dynamic_cast 通常是更好的选择。但是，您还应该考虑完全避免强制转换，而只使用虚函数。


可以让 Operator << 虚拟吗？
    最简洁的答案是不。有许多的原因:
        *首先，只有成员函数可以被虚拟化
            因为我们通常将 operator<< 实现为友元，并且友元不被视为成员函数，所以 operator<< 的友元版本没有资格被虚拟化。

        *其次，即使可以虚拟化操作符<<，Base::operator<<和Derived::operator<<的函数形参也存在差异(Base版本的形参带有Base形参，而Derived版本的形参带有Derived形参)。
            因此，派生版本不会被视为基础版本的覆盖，因此没有资格进行虚函数解析。

    *解决方案:
        eg:11-4

