概述：
    异常类只是一个普通类，专门设计为作为异常抛出。
        eg:3-1

异常和继承:
    note:
        派生异常类的处理程序应该列在基类处理程序之前。
            eg:3-2


std::exception:
    *标准库中的许多类和运算符在失败时会抛出异常类。
        例如，如果 operator new 无法分配足够的内存，它会抛出 std::bad_alloc.等等
        从 C++20 开始，可以抛出 28 种不同的异常类，在每个后续语言标准中都会添加更多

    *好消息是所有这些异常类都派生自一个名为 std::exception 的类（在 <exception> 标头中定义）。
        std::exception 是一个小型接口类，旨在用作 C++ 标准库抛出的任何异常的基类。
            很多时候，当标准库抛出异常时，我们不会关心它是错误的分配、错误的强制转换还是其他什么。我们只关心发生了灾难性的问题，现在我们的程序正在爆炸。
                感谢 std::exception，我们可以设置一个异常处理程序来捕获 std::exception 类型的异常，最终我们将在一个地方同时捕获 std::exception 和所有派生异常。简单！
                    eg:3-3

    *请记住，只有在 try 块中抛出的异常才有资格被捕获。这意味着在 catch 块中抛出的异常不会被它所在的 catch 块捕获。相反，它会向上传播到调用者的堆栈。
    


从 std::exception 或 std::runtime_error 派生您自己的类:
    *您可以从 std::exception 派生您自己的类，并覆盖虚拟 what() const 成员函数。
        eg: 3-4,3-5

    *是否要创建自己的独立异常类、使用标准异常类或从 std::exception 或 std::runtime_error 派生自己的异常类取决于您。根据您的目标，所有方法都是有效的方法。




重新抛出异常：

    重新抛出异常会导致几张不太好的影响:
        *首先，这不会抛出与捕获的完全相同的异常——相反，它会抛出变量异常的复制初始化副本.尽管编译器可以自由地删除副本，但它可能不会，所以这可能会降低性能。
        *其次，异常类会导致切片


    幸运的是，C++ 提供了一种重新抛出与刚刚捕获的完全相同的异常的方法
        为此，只需在 catch 块中使用 throw 关键字（没有关联变量）
            eg:3-6



